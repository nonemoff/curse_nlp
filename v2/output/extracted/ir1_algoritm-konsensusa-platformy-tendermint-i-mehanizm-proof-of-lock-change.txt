International Journal of Open Information Technologies ISSN: 2307-8162 vol. 7, no.6, 2019 
 
 
  
Аннотация—В 
работе 
рассматривается 
алгоритм 
консенсуса, 
основанный 
на 
задаче 
о 
византийских 
генералах, в форме, которой он реализован в платформе 
Tendermint. Этот алгоритм применяется в реализации 
децентрализованных приложений и платежных системах с 
представлением данных на основе технологии блокчейна с 
целью достижения консенсуса между пользователями 
относительно очередного блока, добавляемого в цепочку 
блоков. Особенностью алгоритма консенсуса Tendermint 
является то, в нём участвует не любой желающий из числа 
абонентов сети, а только специальные участники, которые 
называются валидаторами. В работе приводится описание 
алгоритма консенсуса, структур данных, представляющих 
собой голоса валидаторов с некоторым весом, условия, с 
помощью которых формируется голос в рамках алгоритма 
консенсуса, а также механизма Proof Of Lock Change. 
Доказывается конечность, корректность и валидность 
этого 
алгоритма 
при 
условии, 
что 
количество 
валидаторов, которые изолированы от системы или 
которые 
совершают 
действия, 
не 
соответствующие 
алгоритму консенсуса, не превышает одной трети от 
общего числа валидаторов. Проведен анализ механизма 
Proof Of Lock Change. Показано, что возможные вариации 
алгоритма консенсуса, связанные с отказом от реализации 
механизма Proof Of Lock Change, имеют серьёзный дефект, 
связанный с нарушением свойства конечности, что может 
привести к отказу работы системы.  
 
Ключевые 
слова—блокчейн, 
протокол 
консенсуса, 
tendermint, механизм proof of lock change 
 
I. ВВЕДЕНИЕ 
На сегодняшний день блокчейн является довольно 
известной структурой хранения данных, используемой в 
децентрализованных 
приложениях 
и 
платежных 
системах. Однако ввиду отсутствия единого центра 
управления в таких системах необходим механизм, 
позволяющий участникам сети достичь соглашения 
относительно 
каждого 
блока 
данных, 
который 
добавляется в блокчейн. В работе рассматривается 
алгоритм 
консенсуса, 
основанный 
на 
задаче 
о 
византийских генералах, Byzantine Fault Tolerance 
(BFT), в форме, которой он реализован в Tendermint [1]. 
Данный алгоритм консенсуса является альтернативой 
Статья получена 24 апреля 2019. Исследование выполнено при 
финансовой поддержке РФФИ в рамках научного проекта № 18 –
 29 − 03124\18 
 
И.Ю. Герасимов, Московский государственный университет имени 
М.В. Ломоносова (ilia_gerassimov@mail.ru) 
И.В. Чижов, Московский государственный университет имени М.В. 
Ломоносова, (ichizhov@cs.msu.ru) 
 
алгоритмам типа ProofofWork[4], которые требуют 
вычислительных затрат, и ProofofStake[5], в котором 
ресурс, необходимый для получения прибыли 
с 
добавления блоков в блокчейн, производится самой 
системой. Особенностью алгоритма Tendermint является 
то, что в процессе принятия решения о включении блока 
в цепочку принимается группой специально выбранных 
валидаторов. Это создаёт некоторую централизацию, 
что может повлиять на доверие пользователей такой 
системе. 
Некоторые 
системы 
блокчейн, 
основанные 
на 
Tendermint, отказываются от реализации достаточно 
трудоёмкого в реализации механизма ProofofLock 
Change (PoLC). Главным результатом работы является 
доказательство того, что удаление этого механизма 
приведет к нарушению работы системы и может 
приводить к ситуации рассогласования данных в блоках 
блокчейна.  
II. ОПИСАНИЕ АЛГОРИТМА КОНСЕНСУСА TENDERMINT 
Опишем алгоритм консенсуса, использующийся в 
Tendermint [2, 3]. Назовём высотой блокчейна длину, 
считая от корня блокчейна, самой длинной цепочки 
блоков. 
Пусть в некоторый момент времени блокчейн имеет 
высоту 
𝐻, 
имеется 
набор 
валидаторов 
𝑉. 
Эти 
валидаторы 
в 
рамках 
Tendermint 
осуществляют 
процедуру проверки очередного блока, содержащего 
транзакции, и включение его в цепочку. Для этого 
валидаторы должны достичь согласия или консенсуса о 
рассматриваемом 
блоке. 
Алгоритм 
включения 
следующего блока проходит в течение нескольких 
раундов и заключается в голосовании валидаторов за 
блок. Голос каждого валидатора имеет свой вес. При 
голосовании 
валидаторы 
в 
каждом 
выполняют 
последовательность следующих шагов: 
NewHeight→[Propose → Prevote → Precommit]→Commit. 
Причём шаги NewHeight и Commit зависят только от 
текущей высоты блокчейна, а точнее от высоты, на 
которую добавляется новый блок. Шаги Propose, Prevote 
и Precommit могут быть выполнены последовательно 
несколько раз, каждое выполнение будем называть 
раундом. Таким образом, эти шаги зависят не только от 
высоты блокчейна, но и от номера раунда. Можно 
считать, что каждый шаг алгоритма консенсуса – это 
состояние конечного автомата, а сам алгоритм для 
каждого валидатора – конечный автомат. Под действием 
некоторых событий и условий перехода автомат 
валидатора «путешествует» по своим состояниям. 
Прежде чем переходить к описанию каждого шага 
Алгоритм консенсуса платформы Tendermint 
и механизм Proof Of Lock Change  
И.Ю. Герасимов, И.В. Чижов 
24 
 
 
International Journal of Open Information Technologies ISSN: 2307-8162 vol. 7, no.6, 2019 
 
 
дадим общие условия перехода. Если в каком-то раунде, 
на любом шаге выполняется условие: получено более 
2/3 от общего веса голосов за некоторый блок, то 
необходимо перейти к шагу Commit(height); если 
выполняется условие: получено более 2/3 от общего 
веса голосов Prevote для раунда round+x, 𝑥> 0, то 
перейти к Prevote(height, round+x); и, наконец, если 
выполняется условие: получено более 2/3 от общего 
веса голосов Precommit для раунда round+x, 𝑥> 0, то 
перейти к Precommit(height, round+x). 
Описание шагов протокола начнём с описания 
Сommit(height). 
Он 
заключается 
в 
фиксировании 
момента времени перехода на этот шаг (𝐶𝑜𝑚𝑚𝑖𝑡𝑇𝑖𝑚𝑒), 
ожидании получения блока и переходе на шаг 
NewHeight(height+1). 
Шаг NewHeight(height) заключается в добавлении в 
блок информации о голосах и ожидании «отставших» 
голосов 
до 
момента 
времени 
𝐶𝑜𝑚𝑚𝑖𝑡𝑇𝑖𝑚𝑒+
𝑇𝑖𝑚𝑒𝑜𝑢𝑡𝐶𝑜𝑚𝑚𝑖𝑡 и, наконец, внесение блока в блокчейн. 
Перейдём к описанию шага Propose(height, round). На 
каждом раунде выбирается специальный валидатор 
Proposer, который отправляет сообщение Proposal. 
Функция, по которой определяется Proposer, известна 
всем, ее вычисление не требует взаимодействия с 
другими участниками. Таким образом, по высоте ℎ𝑒𝑖𝑔ℎ𝑡 
и номеру раунда 𝑟𝑜𝑢𝑛𝑑 однозначно определяется 
Proposer. 
Кроме 
того, 
каждый 
валидатор 
имеет 
следующие переменные: 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘, 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 – 
блок и раунд соответственно, для которых во время 
раунда 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 было получено более 2/3 от общего 
веса голосов Prevote за блок этого раунда. Начальное 
значение 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑= −1, при этом 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑<
𝑟𝑜𝑢𝑛𝑑. 
Действия на шаге Propose(height, round) зависят от 
того является ли валидатор Proposer, если это так, то он 
отправляет в систему сообщение Proposal. Опишем 
сообщение 
Proposal. 
Оно 
зависит 
от 
значения 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑. 
Если 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑== −1, 
то 
оно 
содержит новый блок, полученный из текущего 
множества транзакций, и переменную 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘=
−1. Если 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑> −1, то Proposal содержит 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘,  
и 
𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘(𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑, 𝑃𝑟𝑒𝑣𝑜𝑡𝑒𝑠(𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑)), 
где 
𝑃𝑟𝑒𝑣𝑜𝑡𝑒𝑠(𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑) – 
множества 
Prevote 
голосов 
валидатора, 
полученных 
на 
раунде 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑, а 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘 – данные, используемые в 
механизме Proof of Lock Change (PoLC). 
Если же это обычный валидатор, то он ожидает 
получения сообщения Proposal. 
При получении на этом шаге сообщения Proposal, 
необходимо перейти на шаг Prevote(height, round), если 
же сообщение не пришло в течение промежутка 
времени timeoutPropose, то необходимо также перейти 
на шаг Prevote(height, round). 
Задача валидатора на шаге Prevote(height, round) 
сформировать свой голос о блоке и отправить его 
другим валидаторам. Сообщение Prevote содержит блок. 
Если выполнены четыре условия: 
1) −1 < 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑<
 𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘. 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑<
𝑟𝑜𝑢𝑛𝑑, 
здесь 
𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘. 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 – 
значение 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 из сообщения 𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙; 
2) 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘! = 𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑏𝑙𝑜𝑐𝑘, 
здесь 
𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑏𝑙𝑜𝑐𝑘 – блок данных из сообщения 
𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙; 
3) для 
полученных 
голосов 
𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘. 𝑃𝑟𝑒𝑣𝑜𝑡𝑒𝑠(𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑) 
на шаге 𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘. 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 
более 
2/3 
от 
общего 
веса 
голосов 
за 
𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑏𝑙𝑜𝑐𝑘; 
4) 𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑏𝑙𝑜𝑐𝑘 
удовлетворяет 
всем 
требованиям, 
 
которые 
предъявляются 
конкретной реализацией значению блокчейна, 
то валидатор в сообщении Prevote значение блока 
полагает равным значению 𝑃𝑟𝑜𝑝𝑜𝑠𝑎𝑙. 𝑏𝑙𝑜𝑐𝑘. Если 
выполнены условия 1)-3), то выполняется присваивание: 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑≔−1. Если же хотя бы одно из условий 
1)-3) нарушается, то в сообщении в качестве блока 
берётся значение 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘 валидатора. И, наконец, 
если 
условия 
1)-3) 
выполняются, 
а 
условие 
4) 
нарушается, либо если сообщение Propose не было 
получено 
в 
течение 
промежутка 
времени 
𝑡𝑖𝑚𝑒𝑜𝑢𝑡𝑃𝑟𝑒𝑣𝑜𝑡𝑒, то 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘 устанавливается в 
значение 𝑁𝑈𝐿𝐿. 
В конце шага валидатор отправляет сообщение 
Prevote, которое содержит номер раунда, высоту 
блокчейна и сформированный блок. После отправки 
сообщения необходимо перейти на следующий шаг. 
Если валидатор получил более 2/3 от общего веса 
голосов для определенного блока или 2/3 от общего веса 
голосов со значением NULL, то валидатор переходит на 
шаг Precommit(height, round). В том случае, если 
произошло событие timeoutPrevote и получены любые 
голоса с весом более 2/3 от общего веса, то валидатор 
также переходит на шаг Precommit(height, round). 
Опишем шаг Precommit(height, round). Валидатор 
должен сформировать сообщение Precommit, которое 
содержит блок данных, текущую высоту блокчейна и 
номер 
раунда. 
Формирование 
блока 
данных 
в 
сообщении выполняется следующим образом. Если для 
определенного блока 𝑏𝑙𝑜𝑐𝑘 получено более 2/3 от 
общего веса голосов Prevote, то 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘: = 𝑏𝑙𝑜𝑐𝑘; 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑: = 𝑟𝑜𝑢𝑛𝑑; и в Precommit указывается блок 
𝑏𝑙𝑜𝑐𝑘. Если получено более 2/3 от общего веса голосов 
Prevote 
со 
значением 
𝑁𝑈𝐿𝐿, 
то 
полагается 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑: = −1, в Precommit в качестве блока 
указывается 𝑁𝑈𝐿𝐿. Во всех остальных случаях в 
сообщении Precommit в качестве блока указывается 
значение 𝑁𝑈𝐿𝐿. 
Осталось описать для этого шага условие перехода 
на следующий шаг. Если валидатор получил более 2/3 
от общего веса голосов со значением 𝑁𝑈𝐿𝐿, то 
валидатор должен перейти на шаг Propose(height, 
round+1). Если валидатор не завершил работу на этом 
шаге до того как истёк таймаут 𝑡𝑖𝑚𝑒𝑜𝑢𝑡𝑃𝑟𝑒𝑐𝑜𝑚𝑚𝑖𝑡 и 
получены любые голоса с весом более 2/3 от общего 
веса, то перейти на шаг Propose(height, round+1). 
Сделаем небольшое замечание. Как видно, для 
каждого 
шага 
наложено 
временное 
ограничение 
25 
 
International Journal of Open Information Technologies ISSN: 2307-8162 vol. 7, no.6, 2019 
 
 
𝑡𝑖𝑚𝑒𝑜𝑢𝑡𝑃𝑟𝑜𝑝𝑜𝑠𝑒, 𝑡𝑖𝑚𝑒𝑜𝑢𝑡𝑃𝑟𝑒𝑣𝑜𝑡𝑒, 𝑡𝑖𝑚𝑒𝑜𝑢𝑡𝑃𝑟𝑒𝑐𝑜𝑚𝑚𝑖𝑡 
соответственно. Они зависят от номера раунда и 
увеличиваются на некоторую величину с увеличением 
номера раунда. 
III. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ РАБОТЫ 
АЛГОРИТМА КОНСЕНСУСА 
Рассмотрим множество валидаторов с общим весом 
голоса 𝑛= 3𝑓+ 1, где 𝑓 – максимальный вес голоса 
валидаторов, не следующих алгоритму консенсуса. 
Докажем, что корректность алгоритма при условии, что 
𝑓<
1
3 𝑛< 𝑓+ 1. 
Лемма 1. Пусть заданы два множества валидаторов - 
𝑈1 и 𝑈2, каждое из которых имеет общий вес 2𝑓+ 1. 
Тогда в пересечении этих множеств существует хотя 
бы один валидатор, следующий алгоритму консенсуса. 
Доказательство. Для мощности множеств 𝑈1 и 𝑈2 
валидаторов справедливо равенство: 
|𝑈1| + |𝑈2| = 4𝑓+ 2 = 3𝑓+ 1 + 𝑓+ 1 = 𝑛+ 𝑓+ 1, 
поэтому 
|𝑈1 ∩𝑈2| ≥𝑓+ 1 > 𝑓. 
Из 
последнего 
можно 
заключить 
существование 
процесса, следующего алгоритму консенсуса.□ 
Лемма 2. Пусть 𝑓+ 1 валидаторов, следующих 
алгоритму 
консенсуса, 
имеют 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘== 𝑣, 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑== 𝑟0. Тогда ∀𝑟> 𝑟0 в голосе 𝑃𝑟𝑒𝑣𝑜𝑡𝑒 
этих процессов всегда указан либо блок 𝑣, либо 𝑁𝑈𝐿𝐿. 
Доказательство. 
Доказательство 
будем 
вести 
по 
индукции. Рассмотрим 𝑟= 𝑟0 + 1. Согласно алгоритму 
консесуса на шаге Prevote выполняется 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑>
−1 и 𝑟𝑜𝑢𝑛𝑑= 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑+ 1, то есть истинно 
условие, на основании которого валидатор голосует за 
блок 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘== 𝑣. Доказали базис индукции. 
При этом можно заметить, что на раунде 𝑟0 + 1, 
количество Prevote, для которых значение блока не 
равно 𝑣 и не равно 𝑁𝑈𝐿𝐿 будет не больше 𝑛−𝑓−1 =
2𝑓<
2
3 𝑛. Значит выполняются следующие условия: 
1) валидаторы, 
следующие 
алгоритму 
консенсуса, 
не 
изменят 
значение 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 на шаге Precommit и в голосе 
Precommit укажут 𝑁𝑈𝐿𝐿; 
2) валидатор, 
следующий 
алгоритму 
консенсуса, и получивший более 
2
3 𝑛 голосов 
Prevote за блок 𝑣, выполнит присваивания 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘≔𝑣, 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑≔𝑟, а в том 
случае, если голоса за этот блок не были 
получены, 
то 
значения 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘 
и 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 не изменятся. 
Рассмотрим теперь шаг индукции. Пусть утверждение 
леммы выполнено для некоторого 𝑟1 > 𝑟0. Рассмотрим 
𝑟= 𝑟1 + 1 
Согласно условиям a) и б), в течение раундов 
𝑟′: 𝑟0 < 𝑟′ ≤𝑟1 либо не существует блока 𝑣′! = 𝑣, за 
который проголосовали более 
2
3 𝑛 валидаторов, либо 
даже если такой блок существует, то перехода к 
Commit(height+1) выполнено не было. Тогда валидаторы 
из условия леммы, следующие шагу Prevote, не 
выполнят присваивание 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑≔−1. А значит 
дальнейшие 
рассуждения 
полностью 
аналогичны 
рассуждениям из доказательства базы индукции. □ 
Теорема 1. Алгоритм консенсуса корректен, то есть не 
существует двух различных валидаторов, следующих 
алгоритму консенсуса, которые на одной и той же 
высоте добавляют два разных блока (в итоге 
обеспечивается целостность цепочки блокчейна). 
Доказательство. 
Пусть 
на 
некотором 
раунде 
𝑟 
валидатор 𝑉 получил более 
2
3 𝑛 голосов Precommit за 
блок 𝑣𝑉, а валидатор 𝑊 получил более 
2
3 𝑛 голосов 
Precommit за блок 𝑣𝑊 на раунде 𝑟0 ≥𝑟. Рассмотрим 
случай, 
когда 
𝑟0 = 𝑟. 
Тогда, 
согласно 
лемме 
1 
существует хотя бы один валидатор, следующий 
алгоритму консенсуса, который отправил Precommit и 
для 𝑣𝑉, и для 𝑣𝑊 в раунде 𝑟. Но по алгоритму 
консенсуса Precommit в раунде отправляется 1 раз. 
Тогда 𝑣𝑉== 𝑣𝑊.  
Пусть теперь 𝑟0 > 𝑟. На раунде 𝑟 валидатор 𝑉 
получил более 
2
3 𝑛 голосов валидаторов, то есть не менее 
2𝑓+ 1 сообщений Precommit за блок 𝑣, значит не менее 
2𝑓+ 1 −𝑓= 𝑓+ 1 валидаторов, следующих алгоритму 
консенсуса, имеют: 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘= 𝑣𝑉, 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑=
𝑟0. Тогда по лемме 2 на раунде 𝑟0 они отправили голос 
Prevote за блок 𝑣𝑉 или 𝑁𝑈𝐿𝐿. 
Валидатор 𝑊 получил 2𝑓+ 1 голосов Precommit за 
блок 𝑣𝑊. Среди 2𝑓+ 1 валидаторов есть те, которые 
следуют алгоритму консенсуса. Рассмотрим любой из 
этих валидаторов. Согласно алгоритму консенсуса, он 
мог отправить голос Precommit за блок 𝑣𝑊 тогда и 
только тогда, когда получил не менее 2𝑓+ 1 голосов 
Prevote за этот блок. При этом среди 3𝑓+ 1 голосов 
Prevote 𝑓+ 1 из них были за блок 𝑣𝑉. Но 𝑓+ 1 + 2𝑓+
1 = 3𝑓+ 2 > 3𝑓+ 1, поэтому 𝑣𝑉= 𝑣𝑊. □ 
Теорема 2. Алгоритм консенсуса валиден, то есть 
валидатор, следующий алгоритму консенсуса, внесет 
блок, удовлетворяющий требованиям блокчейна. 
Доказательство. 
Проверка 
требований, 
которые 
накладываются на блок, в Tendermint является внешней 
функцией по отношению к модулю, в котором указан 
алгоритм консенсуса, поэтому принимаем то, что если 
эта функция вызывается и возвращает true, то блок 
требованиям удовлетворяет. Этот вызов происходит во 
время шага Prevote. Так как в алгоритме максимальное 
количество валидаторов, которые не работают согласно 
алгоритму консенсуса, равно 𝑓< 2𝑓+ 1, то невозможно 
получить 
2𝑓+ 1 
голосов 
Prevote 
за 
блок, 
неудовлетворяющий требованиям. Тогда валидаторы, 
следующие алгоритму консенсуса, на любом раунде не 
будут 
отправлять 
голос 
Precommit 
за 
блок, 
неудовлетворяющий 
требованиям, 
и 
по 
аналогии 
получаем, что невозможно получить 2𝑓+ 1 голосов 
Precommit за блок, неудовлетворяющий требованиям.□ 
Теорема 3. Алгоритм консенсуса конечен, то есть 
валидатор, следующий алгоритму консенсуса, добавит 
блок за конечное время. 
Доказательство. В начале каждого последующего 
раунда длительность каждого шага увеличивается. Это 
означает, что валидатор через конечное число раундов 
сможет получить все голоса. При этом, если валидаторы 
26 
 
International Journal of Open Information Technologies ISSN: 2307-8162 vol. 7, no.6, 2019 
 
 
находятся на разных раундах, то за счет общих условий 
перехода валидатор перейдет на наибольший раунд, 
получив голоса, указанные в переходах. Остается 
ситуация, когда валидатор, следующий алгоритму 
консенсуса, не получает не менее 2𝑓+ 1 голосов 
Precommit за некоторый блок 𝑣. Рассмотрим 2 ситуации. 
Первая – пусть к началу раунда не существует двух 
множеств валидаторов 𝑈1 и 𝑈2, что 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘1! =
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘2 и |𝑈1| >
1
3 𝑛, |𝑈2| >
1
3 𝑛. 
Валидатор, 
следующий 
алгоритму 
консенсуса, 
отправляет голос Precommit за блок 𝑣 тогда и только 
тогда, когда он получил не менее 2𝑓+ 1 голосов Prevote 
за этот же блок. Рассмотрим некоторый валидатор, 
следующий алгоритму консенсуса, который отправил 
Precommit за блок 𝑣. За этот же блок получено менее 2𝑓 
других 
голосов 
Precommit, 
блоков, 
следующих 
алгоритму консенсуса, что не менее 2𝑓+ 1. Тогда 
существует другой валидатор, следующий алгоритму 
консенсуса, который проголосовал Precommit за блок 
𝑣’! = 𝑣. Получаем, что эти валидаторы получили не 
менее 2𝑓+ 1 голосов Prevote за блоки 𝑣 и 𝑣’. Тогда не 
менее 2𝑓+ 1 −𝑓= 𝑓+ 1 валидаторов, следующих 
алгоритму 
консенсуса, 
имеют: 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘= 𝑣, 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑= 𝑟. И еще не менее 𝑓+ 1 валидаторов, 
следующих 
алгоритму 
консенсуса, 
имеют: 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘= 𝑣′, 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑= 𝑟. Сумма мощностей 
этих множеств больше или равна 𝑓+ 1 + 𝑓+ 1 = 2𝑓+
2 > 2𝑓+ 1, все валидаторы этих множеств следуют 
алгоритму консенсуса, кроме того, пересечение этих 
множеств 
непустое, 
поэтому 
𝑣′ = 𝑣. 
Получаем 
противоречие с тем, что не существует раунда, на 
котором получено не менее 2𝑓+ 1 Precommit за 
определенный блок. 
Вторая ситуация: к началу раунда существуют два 
множества 
валидаторов 
𝑈1 
и 
𝑈2, 
для 
которых 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘1! = 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘2 и |𝑈1| >
1
3 𝑛, |𝑈2| >
1
3 𝑛. 
Такая ситуация возникает в случае, когда валидаторы не 
успевают получить все голоса и срабатывают таймауты.  
Тогда на некотором раунде будет Proposer, который 
отправит блок из 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘 и согласно шагу Prevote 
блоки одного из этих множеств валидаторов выполнят 
присваивание 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑: = −1, т.е. возникает первая 
ситуация.□ 
IV. АНАЛИЗ МЕХАНИЗМА PROOF OF LOCK CHANGE 
В 
описанном 
протоколе 
консенсуса 
Tendermint 
валидатор, 
который 
на 
этом 
раунде 
становится 
Proposer’ом, в случае, если 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑! = −1, должен 
отправить блок из 𝑏𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘 и номер раунда, на 
котором он был получен. Номер раунда передаётся в 
сообщении, которое называется ProofOfLock. Далее на 
шаге Prevote, если валидатор видит, что 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘>
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑> −1, то он должен убедиться, что 
действительно за текущий блок получено более 
2
3 𝑛 от 
общего веса голосов Prevote. Видится, что эта проверка 
является лишней (отказ от пункта 3 в условии шага 
Prevote). Действительно, в дальнейшем валидатор 
переходит на шаг Precommit только в том случае, если 
за блок проголосовало более 
2
3 𝑛 валидаторов. Однако 
это не так. Рассмотрим две различные вариации 
протокола, в которых механизм Proof of Lock Change не 
используется: 
a) Не выполняется проверка пунктов 1)-3) на 
шаге Prevote, то есть полностью убрано поле 
ProofOfLock. 
Тогда в новой реализации получаем, что на шаге 
Prevote отправляется голос либо за блок, указанный в 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘, 
если 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑> −1, 
либо 
за 
полученный блок, удовлетворяющий всем требованиям 
системы, если 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑== −1, либо не отдаёт свой 
голос ни одному блоку, отправляя в систему 𝑁𝑈𝐿𝐿. 
Предположим, что к некоторому раунду возникло 2 
множества 
валидаторов 
𝑈1 и 𝑈2, 
у 
которых 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘1 ≠𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘2. 
Не 
ограничивая 
общности, 
будем 
считать, 
что 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑1 <
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑2 < 𝑟𝑜𝑢𝑛𝑑. Пусть также |𝑈1| >
1
3 𝑛, |𝑈2| >
1
3 𝑛. Такие множества могут образоваться за счет того, 
что валидаторы не будут успевать получать все голоса 
других валидаторов.  
Затем после окончания раунда увеличится время 
длительности шагов, но для любого раунда будут два 
множества, которые всегда будут голосовать за свой 
блок, так как в модификации алгоритма изменение 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 может быть произведено только на шаге 
Precommit, но никогда не будет более 
2
3 𝑛 голосов хотя 
бы за один из конкурирующих блоков. В итоге 
нарушается условие конечности алгоритма консенсуса. 
Таким 
образом, 
увеличение 
длительности 
шагов 
теоретически может привести к нештатной ситуации. 
b) Не выполняется проверка пункта 3) на шаге 
Prevote, то есть ProofOfLock посылается, но 
отсутствует механизм Proof of Lock Change. 
Аналогично пункту a) предположим возникновение 
двух множеств 𝑈1 и 𝑈2 с теми же условиями. Пусть 
теперь 𝑃𝑟𝑜𝑝𝑜𝑠𝑒𝑟 на некотором раунде не последует 
алгоритму консенсуса и отправит валидаторам блок 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘1 
с 
раундом 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑2. 
Тогда 
валидаторы из множества 𝑈1, согласно алгоритму, 
меняют 
значение 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑≔𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑2, 
а 
валидаторы из множества 𝑈2 не меняют значения, так 
как они уже «заблокированы» на 𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑2. 
Получаем два множества 𝑈1 и 𝑈2, которые для одного и 
того 
же 
раунда 
𝑙𝑜𝑐𝑘𝑒𝑑𝑟𝑜𝑢𝑛𝑑 
имеют 
разные 
𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘. 
Теперь валидаторы из 𝑈1 будут каждый раунд 
голосовать за 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘1, а из 𝑈2 за 𝑙𝑜𝑐𝑘𝑒𝑑𝑏𝑙𝑜𝑐𝑘2, так 
как они заблокированы на этих блоках. Разблокировка 
возможна только в случае, если будет сформирован 
новый 𝑃𝑟𝑜𝑜𝑓𝑜𝑓𝐿𝑜𝑐𝑘, т.е. набраны 
2
3 𝑛 𝑃𝑟𝑒𝑣𝑜𝑡𝑒 голосов 
за какой-либо блок, либо 
2
3 𝑛 голосов за 𝑁𝑈𝐿𝐿. Это 
невозможно из-за того, что ни значение 𝑁𝑈𝐿𝐿, ни 
некоторый валидный блок не наберут больше 𝑛−
min(|𝑈1|, |𝑈2|) <
2
3 𝑛 голосов. Но отправка голоса на 
шаге 𝑃𝑟𝑒𝑐𝑜𝑚𝑚𝑖𝑡 будет произведена только если за 
27 
 
International Journal of Open Information Technologies ISSN: 2307-8162 vol. 7, no.6, 2019 
 
 
некоторый блок получено более 
2
3 𝑛 𝑃𝑟𝑒𝑣𝑜𝑡𝑒 голосов, 
т.е. не будет более 
2
3 𝑛 𝑃𝑟𝑒𝑐𝑜𝑚𝑚𝑖𝑡 голосов за некоторый 
блок и опять нарушается условие конечности. 
Таким образом, при отсутствии механизма Proof Of 
Lock Change, нарушается условие конечности алгоритма 
консенсуса. 
V. ЗАКЛЮЧЕНИЕ 
В работе рассмотрен алгоритм консенсуса Tendermint[1] 
и механизм Proof Of Lock Change, применяемый в этом 
алгоритме. Было доказано, что алгоритм конечен, 
валиден и корректен. Кроме того, в работе установлено, 
что критически важной частью этого алгоритма 
является механизма Proof Of Lock Change, т.к. отказ от 
него ведёт к потенциальному нарушению конечности 
алгоритма консенсуса. 
БИБЛИОГРАФИЯ 
[1] www.tendermint.com: 
официальный 
сайт. 
URL: 
https://www.tendermint.com/ (дата обращения: 03.04.2019). 
[2] www.tendermint.com/docs/: официальная документация проекта. 
URL: 
https://www.tendermint.com/docs/spec/consensus/consensus.html 
(дата обращения: 03.04.2019). 
[3] Buchman E., Kwon J., Milosevic Z. The latest gossip on BFT 
consensus [электронный ресурс]. 2018. 24 сен. 14 c. // arxiv.org: 
электронный 
архив. 
1991. 
авг. 
URL: 
https://arxiv.org/pdf/1807.04938.pdf (дата обращения: 03.04.2019). 
[4] Nakamoto S. Bitcoin: A Peer-to-Peer Electronic Cash System 
[электронный ресурс]. 2008. 9 с. // bitcoin.org: Bitcoin - Open 
source P2P money URL: https://bitcoin.org/bitcoin.pdf (дата 
обращения: 03.04.2019). 
[5] Wood G. Ethereum: a secure decentralised generalised transaction 
ledger [электронный ресурс]. 32 c. // gavwood.com: сайт 
разработчика 
URL: 
https://gavwood.com/paper.pdf 
(дата 
обращения: 03.04.2019). 
 
 
 
 
28 
 
International Journal of Open Information Technologies ISSN: 2307-8162 vol. 7, no.6, 2019 
 
 
Abstract—This work represents a consensus algorithm in a 
form of Tendermint’s realization which is based on Byzantine 
Generals problem. This algorithm is used in order to achieve 
consensus among the participants over the next block in 
blockchain in decentralized applications and payment systems 
with data representation in the form of blockchain. The main 
feature of the Tendermint consensus algorithm is that the 
protocol participants are special network nodes, who are called 
validators. The paper describes the consensus algorithm, data 
structures representing validator voices with some weight, and 
the Proof Of Lock Change mechanism. It has been proved the 
finiteness, correctness and validity of this algorithm in 
condition the number of validators which are isolated from the 
system or perform acts which do not correspond to the 
consensus algorithm does not exceed one third of the total 
number of validators. Analysis of Proof of lock Change 
mechanism was performed. It is shown that all possible 
variations of the consensus algorithm in which Proof of lock 
Change mechanism is not implemented have a serious defect 
the violation of finiteness property of consensus algorithm, 
which can lead to system failure. 
 
Keywords—blockchain, consensus protocol, tendermint, 
proof of lock change mechanism 
REFERENCES 
[1] www.tendermint.com: 
official 
site. 
URL: 
https://www.tendermint.com/ (data obrashhenija: 03.04.2019). 
[2] www.tendermint.com/docs/: 
official 
documentation. 
URL 
[jelektronnyj 
resurs]: 
https://www.tendermint.com/docs/spec/consensus/consensus.html 
(data obrashhenija:: 03.04.2019). 
[3] Buchman E., Kwon J., Milosevic Z. The latest gossip on BFT 
consensus 
[jelektronnyj 
resurs]. 
2018. 
URL: 
https://arxiv.org/pdf/1807.04938.pdf (data obrashhenija: 03.04.2019). 
[4] Nakamoto S. Bitcoin: A Peer-to-Peer Electronic Cash System 
[jelektronnyj resurs]. 2008. 9 с. // bitcoin.org: Bitcoin - Open source 
P2P money URL: https://bitcoin.org/bitcoin.pdf (data obrashhenija: 
03.04.2019). 
[5] Wood G. Ethereum: a secure decentralised generalised transaction 
ledger [jelektronnyj resurs]. 32 c. // gavwood.com: official site URL: 
https://gavwood.com/paper.pdf data obrashhenija: 03.04.2019). 
 
Consensus algorithm of Tendermint platform 
and Proof Of Lock Change mechanism  
Ilya Gerasimov, Ivan Chizhov 
29 
 
